/ / 是外框 像是 字串的" " 框在/ /裡面的會套用正則表達式

/a/	含字母 “a” 的字串，例如 “ab”, “bac”, “cba”	
/a./	含字母 “a” 以及其後任一個字元的字串，例如 “ab”, “bac”（若要比對.，請使用 \.）	
/^xy/	以 “xy” 開始的字串，例如 “xyz”, “xyab”（若要比對 ^，請使用 \^）	
/xy$/	以 “xy” 結尾的字串，例如 “axy”, “abxy”以 “xy” 結尾的字串，例如 “axy”, “abxy” （若要比對 $，請使用 \$）

預先定義的字元類別:
.	符合任一字元
\d	等於 [0-9] 數字
\D	等於 [^0-9] 非數字
\s	等於 [ \t\n\x0B\f\r] 空白字元
\S	等於 [^ \t\n\x0B\f\r] 非空白字元
\w	等於 [a-zA-Z_0-9] 數字或是英文字
\W	等於 [^a-zA-Z_0-9] 非數字與英文字

.bc  =  abc vbc dbc xbc都可以 因為.代表任意字元

「字元類」（Character class）來比較一組字元範圍，例如：
[abc]	a、b或c 
[13784] 1、3、7、8或4 
[^abc]	非a、b、c的其它字元
[a-zA-Z]	a到z或A到Z（範圍）
[a-d[m-p]]	a到d或m到p（聯集）
[a-z&&[def]]	d、e或f（交集）
[a-z&&[^bc]]	a到z，除了b與c之外（減集）
[a-z&&[^m-p]]	a到z且沒有m到p（a-lq-z）（減集）

一次只指定一個字元不過癮，也可以用Greedy quantifiers來指定字元可能出現的次數：
X = 任一字元
X?	X出現一次或完全沒有
X*	X出現零次或多次
X+	X出現一次或多次
X{n}	X出現n次
X{n,}	X出現至少n次
X{,n}	X出現最多n次
X{n,m}	X出現至少n次，但不超過m次

^ 比對輸入列的啟始位置 /^A/ 可比對 “Abcd” 中的 “A”，但不可比對 “aAb”
$	比對輸入列的結束位置	/A$/ 可比對 “bcdA” 中的 “A”，但不可比對 “aAb”
*	比對前一個字元零次或更多次	/bo*/ 可比對 “Good boook” 中的 “booo”，亦可比對 “Good bk” 中的 “b”
+	比對前一個字元一次或更多次，等效於 {1,}	/a+/ 可比對 “caaandy” 中的 “aaa”，但不可比對 “cndy”
?	比對前一個字元零次或一次	/e?l/ 可比對 “angel” 中的 “el”，也可以比對 “angle” 中的 “l”
.	比對任何一個字元（但換行符號不算）	/.n/ 可比對 “nay, an apple is on the tree” 中的 “an” 和 “on”，但不可比對 “nay”
(x)	比對 x 並將符合的部分存入一個變數	/(a*) and (b*)/ 可比對 “aaa and bb” 中的 “aaa” 和 “bb”，並將這兩個比對得到的字串設定至變數 RegExp.$1 和 RegExp.$2。
xy	比對 x 或 y	/a*b*/g 可比對 “aaa and bb” 中的 “aaa” 和 “bb”


Scanner scanner = new Scanner(System.in);
 
String str = "abcdefgabcabc"; 
System.out.println(str.replaceAll(".bc", "###"));       ###defg###### 

System.out.print("輸入手機號碼: ");                     輸入手機號碼: 0988-100432
str = scanner.next();

// 簡單格式驗證 
if(str.matches("[0-9]{4}-[0-9]{6}")) 
    System.out.println("格式正確"); 
else 
    System.out.println("格式錯誤");

System.out.print("輸入href標籤: "); 
// Scanner的next()方法是以空白為區隔
// 我們的輸入有空白，所以要執行兩次
str = scanner.next() + " " + scanner.next();

// 驗證href標籤 
if(str.matches("<a.+href*=*['\"]?.*?['\"]?.*?>"))     <a href="https://openhome.cc">
    System.out.println("格式正確"); 
else
    System.out.println("格式錯誤");

System.out.print("輸入電子郵件: ");                     
str = scanner.next();

// 驗證電子郵件格式 
if(str.matches(                                        justin@openhome.cc
"^[_a-z0-9-]+([.][_a-z0-9-]+)*@[a-z0-9-]+([.][a-z0-9-]+)*$"))   
    System.out.println("格式正確"); 
else
    System.out.println("格式錯誤"); 

IPv4
/^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$/

MAC _ IEEE 802 MAC-48 標準格式 _ 6 組由 : 或 - 做區隔的雙位數 16 進制數字
/^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/

驗證使用者帳號，第一個字不為數字，只接受 大小寫字母、數字及底線
/^[a-zA-Z]\w*$/

密碼 _ 高強度密碼，6 位數以上，並且至少包含大寫字母、小寫字母、數字、符號各一 _ 若需要調整，將其對應的小括號內容拿掉即可
/^(?=.*[^a-zA-Z0-9])(?=.*[A-Z])(?=.*[a-z])(?=.*\d).{6,}$/

電子郵件，以下的範例並沒有相容 RFC5322 規範，但是已經可以驗證大多數的電子郵件
/^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4})*$/

URL 網址，允許 http, https, ftp 協定，並且可取出 Protocol, Domain, Path, Query
/^(?:(https?|ftp):\/\/)?((?:[a-zA-Z0-9.\-]+\.)+(?:[a-zA-Z0-9]{2,4}))((?:/[\w+=%&.~\-]*)*)\??([\w+=%&.~\-]*)$/

主流信用卡
/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6011[0-9]{12}|622((12[6-9]|1[3-9][0-9])|([2-8][0-9][0-9])|(9(([0-1][0-9])|(2[0-5]))))[0-9]{10}|64[4-9][0-9]{13}|65[0-9]{14}|3(?:0[0-5]|[68][0-9])[0-9]{11}|3[47][0-9]{13})*$/

美國運通信用卡
/^(3[47][0-9]{13})*$/

MasterCard
/^(5[1-5][0-9]{14})*$/

Visa 卡
/^(4[0-9]{12}(?:[0-9]{3})?)*$/

日期 (MM/DD/YYYY)
/^((0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2})*$/

日期 (YYYY/MM/DD)
/^(((?:19|20)[0-9]{2})[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01]))*$/

台灣手機號碼
/^09\d{2}-?\d{3}-?\d{3}$/

中文 (Unicode)
[\u4e00-\u9fa5]

簡易驗證台灣身份證，仍然需要一些進階的檢查，如驗證檢查碼，或前往內政部戶政司驗證
/^[A-Za-z][1-2]\d{8}$/

正整數
/^\+?\d+$/

整數
/^[+-]?\d+$/

float
/^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/
