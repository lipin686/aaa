
https://www.gushiciku.cn/pl/po0Q/zh-tw
https://www.cnblogs.com/starcrm/p/12971702.html

唯一索引也稱為「不可重複索引」，在一個表格中，設定為唯一索引的欄位值不可以重複，但是可以儲存「NULL」值。
非唯一索引就只是用來增加查詢與維護資料效率的索引。設定為非唯一索引的欄位值可以重複，也可以儲存「NULL」值。
全文檢索則是只能用在「 CHAR 」、「 VARCHAR 」與「 TEXT 」型態的欄位字元型態且允許 「NULL」的欄位所組成。

複合索引:
複合索引通過最左前綴( Leftmost Prefixing )的概念，以最左邊的條件為優先
假設name, age, sex
會優先name，再來age，最後sex
在創建name, age, sex複合索引時，同時也創建了其他索引
name,age,sex            
name,age    
name
會多創建一個單一索引name跟兩個複合索引
不包括age 和 sex 和 age,sex  

直接建立索引：
CREATE INDEX email_index ON member(email);
ALTER TABLE member ADD INDEX(email);

刪除索引：
DROP INDEX email ON member;
DROP INDEX 'PRIMARY' on member;
alter table member drop index email_index ;
alter table member drop primary key ;

查看索引:
SHOW INDEX FROM member

建立索引時需要考慮的原則:
最常見在「WHERE」子句中判斷條件的欄位，還有「 ORDER BY 」與「 GROUP BY 」中指定的欄位，也都可以使用建立索引來增加效率。
不過建立這樣的索引的前提，表格所儲存的資料量要夠大，如果量不大的話，建立索引反而會浪費儲存的空間，效率也增加不多，而且還會讓執行新增或修改時的效率變差。
1.選擇唯一性索引: 唯一性索引的值是唯一的，可以更快速的透過該索引來ˊ找尋資料。
2.經常需要排序、分組和操作的欄位建立索引: 排序會浪費很多時間。如果建立索引，可以有效地避免排序操作。
3.索引不要建立過多: 索引的數目不是越多越好。每個索引都需要佔用空間，索引越多，需要的空間就越大。
4.索引的欄位儘量不要有「NULL」值
5.最左前綴匹配原則: 最具識別性的欄位放在鍵的左邊
6.雖然某個欄位很常使用在 WHERE、 ORDER BY 或 GROUP BY 子句中，也不一定要建立索引。例如性別欄位的值只有兩種(F , M)，建立索引所增加的效率也不多
7.如果有 or，where 後面就必須全部條件有 index，否則 index 將不會起作用，所以要使用 or 的就要為相對應的欄位加上 index


原理:
為什麼MySQL要使用InnoDB作為預設的儲存引擎，使用B+Tree資料結構呢?
先說明為什麼不用其他的資料結構

二叉樹:
O(log2(n))的時間複雜度但有可能全部排在同一邊，查詢時間就大幅增加，所以不適合索引的資料結構

平衡二叉樹(AVL Tree):
               10
              數據
              p1|p2
            /       \
           5        20
          數據      數據
       null|null null|null
AVL很好的解決了線性問題，使每個節點高度差不超過1，但是還是不適合
1.搜尋效率不足，資料量一大，樹的高度會變很恐怖，搜尋時間就會很可怕
2.每個節點都要進行一次讀取比對，耗費大量效能
3.查詢效率不穩定，雖然是O(log2(n))但可能第一次找到或最底下找到
4.每個節點儲存資料太小，作業系統和磁碟之間一次資料交換是以頁為單位的，一頁大小為4K，即每次IO作業系統會將4K資料載入進記憶體。
但是，在二叉樹每個節點的結構只儲存一個關鍵字，一個數據區，兩個子節點的引用，並不能夠填滿4K的內容

多路平衡查詢樹(B Tree):
為了解決上面的問題，而專為磁碟盤的資料結構就是B Tree
B Tree是一個絕對平衡樹 節點內的資料數量=路數-1 高度大致上在3~4

先看看B+Tree再來說明兩者的不同
B+Tree:
1.路數跟資料數為1:1 一個節點內有3個資料就分三條線路
2.除了葉子節點，其他節點都只儲存指標，葉子節點儲存所有資料
3.B+Tree葉子節點是順序排列的，並且相鄰的節點具有順序引用的關係 葉子節點之間有指標相連
4.B+Tree 關鍵字的搜尋採用的是左閉合區間

為什麼要選B+Tree:
1.查詢效率穩定，因為資料放在葉子節點 所以查詢IO次數固定
2.B+Tree掃庫和掃表能力更強。如果我們要根據索引去進行資料表的掃描，對B TREE進行掃描，需要把整棵樹遍歷一遍，而B+TREE只需要遍歷他的所有葉子節點即可（葉子節點之間有引用）
3.B+TREE磁碟讀寫能力更強。他的根節點和支節點不儲存資料區，所以根節點和支節點同樣大小的情況下，儲存的關鍵字要比B TREE要多。
而葉子節點不儲存子節點引用，能用於儲存更多的關鍵字和資料。所以，B+TREE讀寫一次磁碟載入的關鍵字比B TREE更多。
4.B+Tree排序能力更強。上面的圖中可以看出，B+Tree天然具有排序功能。

MySQL為了很好的利用磁碟的預讀能力，將頁大小設定為16K，即將一個節點（磁碟塊）的大小設定為16K，一次IO將一個節點（16K）內容載入進記憶體
我们假设一行的数据是1K，那我们一页的数据，就能存储16行数据，也就是一个叶节点可以存储16条记录；
再来看非叶节点，假设ID是bigint类型，那么长度为8B，指针大小在InnoDB源码中为64（6B），一共就是14B，那么一页里面就可以存储16K/14=1170个（主键+指针）
根节点指针数 * 单个叶子节点记录行数
那么一棵高度为2的B+树能存储的数据为 1170 * 16=18720条
一棵高度为3的B+树可以存储1170 * 1170 * 16 = 21902400（两千万条）

再來說明如何儲存資料
MYISAM儲存引擎儲存資料庫資料，一共有三個檔案：
Frm：表的定義檔案。
MYD：資料檔案，所有的資料儲存在這個檔案中。
MYI：索引檔案。

Innodb儲存引擎儲存資料庫資料，一共有兩個檔案(沒有專門儲存資料的檔案)：
Frm檔案： 表的定義檔案。
Ibd檔案：資料和索引儲存檔案。資料以主鍵進行聚集儲存，把真正的資料儲存在葉子節點中。

MyISAM的主鍵跟輔助索引的葉子節點都是指向物理地址

Innodb主鍵索引為聚集索引
在Innodb中，聚集索引默認就是主鍵索引，私鑰的意思(ID)
非聚集索引都是額外設定的index
非聚集索引的葉子節點都是存id跟自身資料(username等)
當要查到name就直接跑非聚集索引 跑一次就可返回
select id, username from t1 where username = '小明'           
select username from t1 where username = '小明'
但如果要找score，不在非聚集索引內，就要透過id導回聚集索引，等於跑兩次，所以要設定好索引
select username, score from t1 where username = '小明'

聚簇索引(聚集索引)和非聚簇索引(辅助索引,二级索引)
聚簇索引和非聚簇索引并不是一种类似非空索引,主键索引的索引类型,而是一种数据存储方式
简单的说,聚簇索引就是索引和数据存储在一起,在B+Tree中,表示都一个叶子节点上关键字和它代表的数据行存储在一起
非聚簇索引则是相反. 索引和真正的数据行是分开的. 在B+Tree中,叶子节点上存的是主键id
由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引
如果表中沒有定義主鍵，那麼該表的第一個唯一非空索引被作為聚集索引。
如果沒有主鍵也沒有合適的唯一索引，那麼innodb內部會生成一個隱藏的主鍵作為聚集索引，這個隱藏的主鍵是一個6個字節的列，改列的值會隨著數據的插入自增。


